# 要件定義：Context-MCP（Language Server Protocol based MCP）

## 概要

Context-MCPは、ソースコードとドキュメントを統合的に解析し、セマンティック検索を提供するModel Context Protocol (MCP)プラグインです。Tree-sitterによるAST解析とベクターデータベースを組み合わせることで、Claude Codeに最適化されたコンテキスト理解と効率的なコード検索を実現します。

### 目的
- ソースコードとドキュメントを一体的に理解し、Claude Codeのコンテキスト理解を向上
- AST解析により構造的なコード理解を実現
- ベクターDBによるセマンティック検索で関連性の高い情報を効率的に取得
- トークン使用量を削減しながら、より正確なコンテキストを提供

### 目標
- コンテキストトークン使用量を30-40%削減
- 検索精度を従来の全文検索比で50%以上向上
- 多言語対応（10言語以上）
- ドキュメントとコードの関連性を自動抽出

## 謝辞・インスパイア元

本プロジェクトは、Zillizが開発した[Claude Context](https://github.com/zilliztech/claude-context)から大きなインスパイアを受けています。

Claude Contextは、以下の革新的なアプローチを示してくれました：
- **ハイブリッド検索の有効性**: BM25全文検索とベクトル検索を組み合わせることで、約40%のトークン削減を実現
- **セマンティックコード検索の実用性**: "entire codebase as Claude's context"という明確なビジョン
- **MCP統合の実装パターン**: Model Context Protocolプラグインとしての設計アプローチ

Context-MCPは、Claude Contextのコンセプトを基盤としながら、以下の点でClaude Code環境に最適化した独自の発展を目指します：
- **AST解析の深化**: Tree-sitterによる構造的なコード理解の追加
- **ドキュメント統合の強化**: Markdownやdocstringとコードとのシームレスな関連付け
- **インクリメンタル更新**: ファイル監視による自動更新機能
- **多様なバックエンド対応**: プラグイン方式による柔軟なベクターDB選択

Claude Contextチームの素晴らしい貢献に深く感謝し、オープンソースコミュニティへの敬意を表します。

## ユーザーストーリー

### ストーリー1: プロジェクトのインデックス化
**私は** Claude Codeユーザーとして
**〜したい** プロジェクト全体（ソースコードとドキュメント）を一度にインデックス化したい
**なぜなら** Claude Codeがプロジェクト構造を深く理解し、的確な提案や検索結果を得られるようにするため

#### 受入基準（EARS記法）

- **REQ-001**: ユーザーがインデックス化コマンドを実行した時、システムは指定されたプロジェクトディレクトリ配下のすべての対象ファイルを検出しなければならない
- **REQ-002**: ファイル検出時、システムは.gitignoreおよび.mcpignoreに記載されたパターンを除外しなければならない
- **REQ-003**: ソースコードファイルを処理する時、システムはTree-sitterを使用してAST解析を実行しなければならない
- **REQ-004**: Markdownファイルを処理する時、システムは見出し構造、コードブロック、リンク情報を抽出しなければならない
- **REQ-005**: インデックス化処理中、システムは進捗状況（処理済みファイル数/総ファイル数）をリアルタイムで表示しなければならない
- **REQ-006**: インデックス化完了時、システムは処理サマリー（総ファイル数、成功数、失敗数、処理時間）を表示しなければならない

### ストーリー2: セマンティック検索
**私は** Claude Codeユーザーとして
**〜したい** 自然言語クエリでコードとドキュメントを横断的に検索したい
**なぜなら** キーワードベースでは見つけられない、意味的に関連するコードやドキュメントを発見するため

#### 受入基準（EARS記法）

- **REQ-007**: ユーザーが検索クエリを入力した時、システムは500ms以内にベクトル検索を開始しなければならない
- **REQ-008**: 検索実行時、システムはハイブリッド検索（BM25全文検索 + ベクトル検索）を実行しなければならない
- **REQ-009**: 検索結果を返す時、システムは関連度スコアの高い順に最大20件の結果を返さなければならない
- **REQ-010**: 各検索結果に対して、システムはファイルパス、行番号、コードスニペット、関連度スコアを含めなければならない
- **REQ-011**: もしコードとドキュメントの両方がヒットした場合、システムは両者の関連性を示すリンク情報を提供しなければならない

### ストーリー3: コード構造の理解
**私は** Claude Codeユーザーとして
**〜したい** プロジェクト内の関数、クラス、モジュールの定義箇所を素早く特定したい
**なぜなら** コードベース全体の構造を理解し、適切な修正箇所を見つけるため

#### 受入基準（EARS記法）

- **REQ-012**: システムはAST解析により関数定義、クラス定義、インターフェース定義を抽出しなければならない
- **REQ-013**: 各定義に対して、システムは名前、引数、戻り値、docstring/コメントを関連付けなければならない
- **REQ-014**: ユーザーがシンボル検索を実行した時、システムは定義箇所と使用箇所の両方を検索しなければならない
- **REQ-015**: もし同名のシンボルが複数存在する場合、システムはスコープ（ファイル、クラス、関数）を区別して表示しなければならない

### ストーリー4: ドキュメントとコードの関連付け
**私は** Claude Codeユーザーとして
**〜したい** ドキュメントに記載された機能に対応するソースコードを自動的に見つけたい
**なぜなら** 仕様書と実装の整合性を確認し、ドキュメント駆動の開発を効率化するため

#### 受入基準（EARS記法）

- **REQ-016**: システムはMarkdownドキュメント内のコードブロックから言語とコードサンプルを抽出しなければならない
- **REQ-017**: ドキュメントにファイルパスやシンボル名が記載されている時、システムは実際のソースコードへのリンクを生成しなければならない
- **REQ-018**: ユーザーがドキュメントから検索した時、システムは意味的に関連するコード実装を提案しなければならない
- **REQ-019**: もしdocstringやコメントにTODO/FIXME/NOTE等のマーカーがある場合、システムはこれらを特別なカテゴリとして分類しなければならない

### ストーリー5: インクリメンタル更新
**私は** Claude Codeユーザーとして
**〜したい** ファイルを編集した際に、インデックスが自動的に更新されるようにしたい
**なぜなら** 常に最新の状態で検索できるようにし、手動再インデックス化の手間を省くため

#### 受入基準（EARS記法）

- **REQ-020**: ファイルが作成・編集・削除された時、システムはファイルシステム監視により変更を検知しなければならない
- **REQ-021**: 変更検知時、システムは変更されたファイルのみを再インデックス化しなければならない
- **REQ-022**: インクリメンタル更新中、システムは既存の検索機能を中断せずに動作し続けなければならない
- **REQ-023**: もし同じファイルが短時間に複数回編集された場合、システムは最後の変更から500ms後に更新処理を実行しなければならない（デバウンス処理）

### ストーリー6: ローカル完結実行
**私は** プライバシーを重視する開発者として
**〜したい** インターネット接続や外部APIを使用せず、完全にローカル環境で動作させたい
**なぜなら** 企業秘密やセンシティブなコードを外部に送信せず、安全に利用するため

#### 受入基準（EARS記法）

- **REQ-024**: ユーザーがローカルモード設定を有効にした時、システムは外部API（埋め込みサービス、クラウドDB等）への接続を一切行ってはならない
- **REQ-025**: ローカルモード時、システムはローカル埋め込みモデル（Transformers.js）を使用しなければならない
- **REQ-026**: ローカルモード時、システムはMilvus standalone（Docker Compose経由）にデータを保存しなければならない
- **REQ-027**: システムは初回セットアップ時に、ローカルモードまたはクラウドモードの選択肢を提供しなければならない
- **REQ-028**: ローカルモード選択時、システムはMilvus standaloneの起動手順（docker-compose up -d）を案内しなければならない
- **REQ-029**: もしインターネット接続が利用できない環境で実行された場合、システムは自動的にローカルモードで動作しなければならない

### ストーリー7: ゼロコンフィグセットアップ
**私は** Claude Codeユーザーとして
**〜したい** 設定ファイルを作成せず、環境変数のみでContext-MCPを即座に使い始めたい
**なぜなら** Docker Compose起動とMCP設定だけで、すぐにコード検索機能を利用したいため

#### 受入基準（EARS記法）

- **REQ-030**: ユーザーが設定ファイルを作成していない時、システムはデフォルト設定（ローカルモード、Milvus standalone、Transformers.js）で起動しなければならない
- **REQ-031**: ユーザーがClaude CodeのMCP設定で環境変数を指定した時、システムはその環境変数を優先して使用しなければならない
- **REQ-032**: システムは以下の環境変数をサポートしなければならない：LSP_MCP_MODE、LSP_MCP_VECTOR_BACKEND、LSP_MCP_VECTOR_ADDRESS、LSP_MCP_VECTOR_TOKEN、LSP_MCP_EMBEDDING_PROVIDER、LSP_MCP_EMBEDDING_API_KEY
- **REQ-033**: もし設定ファイルと環境変数の両方が存在する場合、システムは「環境変数 > 設定ファイル > デフォルト設定」の優先順位で設定を適用しなければならない
- **REQ-034**: システムは起動時に適用された設定内容（モード、ベクターDB、埋め込みプロバイダー）をログに出力しなければならない

### ストーリー8: 監視とメトリクス
**私は** Context-MCPの運用管理者として
**〜したい** MCPサーバーの動作状況をOpenTelemetryで監視したい
**なぜなら** パフォーマンスボトルネック、エラー発生箇所、リソース使用状況を可視化し、問題を早期発見・解決するため

#### 受入基準（EARS記法）

- **REQ-035**: システムはOpenTelemetry SDKを統合し、トレース、メトリクス、ログの3つの観測シグナルを出力しなければならない
- **REQ-036**: MCPツール（index_project、search_code等）が呼び出された時、システムはツール名、パラメータ、実行時間をトレーススパンとして記録しなければならない
- **REQ-037**: ベクターDB操作（検索、インデックス追加）実行時、システムは操作種別、処理時間、成功/失敗をトレーススパンとして記録しなければならない
- **REQ-038**: システムは以下のメトリクスを1分ごとに収集しなければならない：リクエスト数、リクエスト成功率、平均応答時間、エラー発生回数、インデックス済みファイル数、メモリ使用量
- **REQ-039**: エラーが発生した時、システムはエラー内容、スタックトレース、コンテキスト情報をログとして出力しなければならない
- **REQ-040**: システムはOTLP（OpenTelemetry Protocol）エクスポーター（gRPC/HTTP）をサポートし、外部の監視バックエンド（Jaeger、Grafana Tempo、Prometheus等）にデータを送信できなければならない
- **REQ-041**: もし監視設定が有効でない場合、システムは監視オーバーヘッドを最小化し、通常動作に影響を与えてはならない
- **REQ-042**: ユーザーが設定ファイルまたは環境変数（OTEL_EXPORTER_OTLP_ENDPOINT等）で監視設定を指定した時、システムはその設定を使用してテレメトリデータを送信しなければならない

## 非機能要件

### 性能要件

- **NFR-001**: システムは10,000ファイル規模のプロジェクトを5分以内にインデックス化できなければならない
- **NFR-002**: システムは検索クエリに対して2秒以内に結果を返さなければならない
- **NFR-003**: システムはメモリ使用量を2GB以内に抑えなければならない（中規模プロジェクト想定）
- **NFR-004**: システムはインクリメンタル更新を1ファイルあたり100ms以内に完了しなければならない

### 互換性要件

- **NFR-005**: システムはModel Context Protocol (MCP) v1.0仕様に準拠しなければならない
- **NFR-006**: システムはClaude Code v1.0以降で動作しなければならない
- **NFR-007**: システムはmacOS、Linux、Windows環境で動作しなければならない
- **NFR-008**: システムはNode.js 18.0以降で動作しなければならない

### 拡張性要件

- **NFR-009**: システムは新しいプログラミング言語のTree-sitter文法を、コード変更なしに追加できなければならない
- **NFR-010**: システムは埋め込みモデル（OpenAI、VoyageAI、Transformers.js等）を設定で切り替え可能でなければならない
- **NFR-011**: システムはベクターDBバックエンド（Milvus standalone、Zilliz Cloud）をプラグイン方式で切り替え可能でなければならない

### セキュリティ要件

- **NFR-012**: システムは.envファイルや秘密鍵等のセンシティブファイルをインデックス化してはならない
- **NFR-013**: システムはAPIキーや認証トークンを暗号化して保存しなければならない
- **NFR-014**: システムはベクターDBへの接続をTLS/SSL暗号化を使用して行わなければならない

### プライバシー・ローカル実行要件

- **NFR-015**: システムはデフォルトでローカル完結モードで動作しなければならない
- **NFR-016**: システムはローカルモード時に、ユーザーのコードやドキュメントを外部サーバーに送信してはならない
- **NFR-017**: システムはローカル埋め込みモデル（Transformers.js）をサポートしなければならない
- **NFR-018**: システムはローカルベクターDB（Milvus standalone）をサポートしなければならない
- **NFR-019**: システムはローカルモード時の性能が、クラウドモードと比較して実用的な範囲（2倍以内の処理時間）でなければならない
- **NFR-020**: システムはDocker環境があれば、インターネット接続なしでも基本機能（インデックス化、検索）が動作しなければならない
- **NFR-021**: システムはローカルモデルのダウンロード・更新を、ユーザーの明示的な許可を得た上で実行しなければならない

### ユーザビリティ要件

- **NFR-022**: システムは設定ファイル（.context-mcp.json）により、除外パターン、言語設定、モデル選択を簡単にカスタマイズできなければならない
- **NFR-023**: システムはエラー発生時に、原因と対処方法を含む分かりやすいメッセージを表示しなければならない
- **NFR-024**: システムは初回セットアップ時に対話的な設定ウィザードを提供しなければならない
- **NFR-025**: システムはローカルモードとクラウドモードの切り替えを、設定ファイルまたはCLIオプションで簡単に変更できなければならない
- **NFR-029**: システムは環境変数から設定を読み込む機能を提供しなければならない（LSP_MCP_MODE、LSP_MCP_VECTOR_BACKEND、LSP_MCP_VECTOR_ADDRESS等）
- **NFR-030**: システムは「環境変数 > ユーザー設定ファイル > デフォルト設定」の優先順位で設定を適用しなければならない
- **NFR-031**: システムは設定ファイルなしでも、デフォルト設定（ローカルモード、Milvus localhost:19530、Transformers.js）で起動できなければならない

### 信頼性要件

- **NFR-026**: システムは単一ファイルの解析エラーが原因で全体のインデックス化を中断してはならない
- **NFR-027**: システムはベクターDB接続エラー時に、ローカルキャッシュにフォールバックしなければならない
- **NFR-028**: システムはインデックスデータの破損を検知した場合、自動的に再構築を提案しなければならない

### 監視・可観測性要件

- **NFR-032**: システムはOpenTelemetry API仕様v1.0以降に準拠しなければならない
- **NFR-033**: システムはトレース、メトリクス、ログの3つの観測シグナルをすべてサポートしなければならない
- **NFR-034**: システムは監視機能がオフの場合、テレメトリコレクション処理が通常動作のレイテンシーに5%以上の影響を与えてはならない
- **NFR-035**: システムはOTLPエクスポーター経由でテレメトリデータを送信する際、送信失敗によりメイン処理がブロックされてはならない
- **NFR-036**: システムは環境変数（OTEL_EXPORTER_OTLP_ENDPOINT、OTEL_SERVICE_NAME等）による監視設定をサポートしなければならない
- **NFR-037**: システムは分散トレーシングのコンテキスト伝播をサポートし、外部サービス（ベクターDB、埋め込みAPI）へのリクエストにトレースコンテキストを含めなければならない
- **NFR-038**: システムはヘルスチェックエンドポイント（/health）を提供し、サービスの稼働状態を返さなければならない

## 対応言語

### 優先度：高（初期リリース対応）
- JavaScript / TypeScript
- Python
- Go
- Rust
- Java
- C / C++ (Arduino / PlatformIO対応含む)
  - Arduino (.ino, .cpp, .h)
  - PlatformIO (platformio.ini, .cpp, .h)
  - 標準C/C++ (.c, .cpp, .h, .hpp)

### 優先度：中（v1.1対応）
- Ruby
- PHP
- Swift

### 優先度：低（将来対応）
- Kotlin
- Scala
- Haskell
- その他（コミュニティ要望により追加）

## 対応ドキュメント形式

- Markdown (.md)
- reStructuredText (.rst)
- AsciiDoc (.adoc)
- Jupyter Notebook (.ipynb) - コードセル、マークダウンセル
- Docstring（各言語のドキュメント文字列）

## 依存関係

### 必須依存関係（ローカル完結実行）
- Node.js 18.0+
- Docker & Docker Compose（Milvus standalone実行用）
- Tree-sitter（各言語のパーサー）
- Milvus standalone（Docker Compose経由、ポート19530）
- ローカル埋め込みモデル（Transformers.js）

### オプション依存関係（クラウド連携時）
- Zilliz Cloud（Milvusマネージドサービス）
- 埋め込みAPIキー（OpenAI、VoyageAI）

### オプション依存関係（監視・可観測性）
- OpenTelemetry SDK for Node.js（@opentelemetry/sdk-node）
- OpenTelemetry API（@opentelemetry/api）
- OTLP Exporter（@opentelemetry/exporter-trace-otlp-grpc、@opentelemetry/exporter-metrics-otlp-grpc）
- 監視バックエンド（Jaeger、Grafana Tempo、Prometheus、Grafana等）

### その他のオプション依存関係
- Git（.gitignore解析用）
- ファイルシステム監視ライブラリ（chokidar等）

## スコープ外

本仕様では以下を対象外とします：

- コードの自動リファクタリング機能
- リアルタイムコード補完機能（LSP本来の機能との混同を避けるため）
- ビルドシステムとの統合
- CI/CDパイプラインとの統合
- バイナリファイルの解析
- 画像・動画等のマルチメディアファイルの解析
- プロジェクト間の横断検索（将来機能として検討）

## 成功指標

1. **トークン削減率**: Claude Codeでのコンテキスト取得時のトークン使用量を30%以上削減
2. **検索精度**: 関連性の高い結果を上位5件以内に含む割合が80%以上
3. **処理速度**: 10,000ファイルのインデックス化を5分以内に完了（ローカルモードでは10分以内）
4. **ユーザー満足度**: Claude Codeユーザーのフィードバックで80%以上が「有用」と評価
5. **プライバシー保護**: ローカルモード使用時の外部通信が0件であること
6. **ローカル実行率**: ユーザーの50%以上がローカルモードでの使用を選択すること

## 用語定義

- **AST（Abstract Syntax Tree）**: 抽象構文木。ソースコードの構造を木構造で表現したもの
- **ベクターDB**: ベクトルデータベース。高次元ベクトルの類似検索に特化したデータベース
- **ハイブリッド検索**: 全文検索（BM25等）とセマンティック検索（ベクトル検索）を組み合わせた検索手法
- **埋め込み（Embedding）**: テキストを高次元ベクトル空間の点として表現する技術
- **インクリメンタル更新**: 変更があった部分のみを更新する効率的な更新手法
- **docstring**: ソースコード内に記述されるドキュメント文字列（Pythonの"""..."""等）
- **ローカルモード**: インターネット接続や外部APIを使用せず、完全にローカル環境で動作するモード
- **クラウドモード**: クラウドベースの埋め込みAPIやベクターDBを利用するモード
- **ローカル埋め込みモデル**: デバイス上で実行される機械学習モデル（Transformers.js、ONNX等）
- **プライバシーファースト**: ユーザーデータを外部に送信せず、ローカルで処理することを優先する設計思想
- **OpenTelemetry（OTEL）**: ベンダー中立のオープンソース可観測性フレームワーク。トレース、メトリクス、ログを統合的に収集
- **トレース（Trace）**: 分散システムにおけるリクエストの流れを追跡する仕組み。複数のスパンから構成される
- **スパン（Span）**: トレースの最小単位。単一の処理（関数呼び出し、DB操作等）の開始・終了時刻と属性を記録
- **メトリクス（Metrics）**: システムの状態を定量的に測定する値（カウンター、ゲージ、ヒストグラム等）
- **OTLP（OpenTelemetry Protocol）**: OpenTelemetryの標準プロトコル。gRPCまたはHTTP経由でテレメトリデータを送信
- **可観測性（Observability）**: システムの外部出力（ログ、メトリクス、トレース）から内部状態を推測できる能力
